#+title: Developer Documentation

* Developer Documentation

The majority of documentation for developers exists within each module. The documentation there
is designed primarily for users of this library, but it is also assumed that they may want to
know about internal workings, so that information is included.

This document serves to fill in the gaps and provides a general, high-level overview of the
patterns, conventions, and decisions that exist throughout the entire library.

** Table of Contents :toc_3:
- [[#developer-documentation][Developer Documentation]]
  - [[#naming-convention][Naming Convention]]
  - [[#version-convention][Version Convention]]
  - [[#module-organization][Module Organization]]
  - [[#design-patterns--philosophies][Design Patterns / Philosophies]]
    - [[#using-the-c-standard-library][Using the C Standard Library]]
    - [[#handling-library-inter-dependencies][Handling Library Inter-Dependencies]]
    - [[#handling-external-dependencies][Handling External Dependencies]]

** Naming Convention

*EVERYTHING* that is public facing / publicly accessible is prefixed with ~nsl_~. An additional
prefix will be used that corresponds with the name of the module. This is not always the full
name of the module, but may be a shortened name (similar to how ~nsl~ is the shorted form of
~NonStdLib~). Some, but not all, prefixes can be removed. If removal of a prefix would cause a
name collision, it will not be removed.

- *Functions* - All functions follow the ~snake_case~ naming convention. Any macro that is meant to
  be used as a function also follows the same convention.
- *Structs* - All structs follow the ~PascalCase~ naming convention. This includes any macros that
  evaluates to a struct. All struct member variables follow the ~snake_case~ naming convention.
- *Enums* - All enums follow the ~PascalCase~ naming convention. All enum values follow the
  ~ALL_CAPS~ naming convention.
- *Macros* - With the exception of the macros defined above, all macros follow the ~ALL_CAPS~ naming
  convention.
- *Local Variables* - All local variables follow the ~snake_case~ naming convention. This is not
  particularly relevant to users, but it is important to be consistent.
- *Global Variables* - All global variables follow the ~snake_case~ naming convention and are
  prefixed with ~g_~ (this prefix cannot be removed and should go in front of any library /
  module prefix). Usage of global variables should be avoided if possible.
- *Private Identifiers* - Any identifier that is meant to be private *will not* be included in the
  declaration section of the header file, if possible. Its name will be prefixed with an
  additional underscore (e.g. ~nsl__~ instead of ~nsl_~) which will be after the module name (if
  one exists). They will not support stripping the prefix, and will not be included in the
  global scope (i.e. declared as static), if possible.

** Version Convention

[[https://semver.org][Semantic Versioning]] is used for all version needs. As the library is designed to support copying
single files, the library has a whole does not have a version. Instead, each individual module
has its own version that will be changed independently of the other modules. All modules have
macros (~NSL_<MODULE>_MAJOR~, ~NSL_<MODULE>_MINOR~, and ~NSL_<MODULE>_PATCH~) specifying the current
version of the module.

Editing comments will not change the version at all.
*Patch* will be incremented for bug fixes and refactoring that do not touch the API.
*Minor* will be incremented for new functions, types, etc. that do not touch the existing API.
This also applies for marking items as deprecated.
*Major* will be incremented for changes to the existing API. The API should only change when items
that have been marked as deprecated are removed.

** Module Organization

All modules should follow the organizational layout described below. Some parts of the layout
are not needed for every module, and so they can be skipped.

- *License* - Most modules are designed to be usable without the rest of the library, so
  including a copy of the license is necessary.
- *Module Documentation* - A high-level overview of the module. This generally follows the format
  below.
  - Explanation of what the module provides. This includes pointing out a few types, functions,
    etc. that are good places to get started.
  - Basic example code for using the module.
  - Explanation of each macro flag and how they should be used.
  - Explanation of macros that can be user defined and what they control.
- *Header Section* - The declaration of the interface. This section should be wrapped in a macro
  include guard. The name of the guard should follow the pattern ~NSL_<MODULE>_H_~. The order of
  elements is listed below. If anything is meant to be public facing, it should have an
  associated comment with the definition / declaration.
  - The macros containing the version of the module.
  - Any potential includes.
  - Macros that can be user defined.
  - Everything else is pretty free in terms of order. Generally, the order macros, types, public
    functions, private functions should be followed. But if a macro is a wrapper for a function,
    it may make sense to put it next to that function. Or if a type is only ever meant for one
    function, the same applies.
  - There should be a ~NSL_<MODULE>_DEF~ macro that users can define to restrict functions to be
    ~static~ and/or ~inline~.
- *Implementation Section* - The implementation of the interface. The order of elements here does
  not matter as much, as most users should not need to look through this section. This section
  should be surrounded by a guard with the format ~NSL_<MODULE>_IMPLEMENTATION~.
- *Prefix-Stripping Section* - The definition of macros to strip prefixes. Again, the order of
  elements does not matter too much. This should be placed after everything else, however, so
  that there are no potential conflicts. This section should be surrounded by a guard with the
  format ~NSL_<MODULE>_STRIP_PREFIX_GUARD_~.

** Design Patterns / Philosophies

This section contains some common design patterns and philosophies that are present throughout
this library.

*** Using the C Standard Library

Avoiding use of the C standard library is often impossible and providing a complete and robust
method for users to redefine standard library functions quickly becomes excessive. This is
further exacerbated by the fact that very few systems require avoiding the standard library.
That being said, supporting redefining specific library functions is a good idea.
Specifically, allocating memory, accessing the file system, printing text, and other similar
functions should support wrappers that the user can redefine.

*** Handling Library Inter-Dependencies

As each module is meant to belong to the same, single library, inter-library dependencies will
naturally occur. For some, larger modules, avoiding those dependencies is incredibly
difficult or impossible, so they are acceptable. For smaller modules, including the
dependencies by default, but having a macro flag that can remove the dependency is the
preferred method.

*** Handling External Dependencies

As each module is meant to be usable on their own, requiring external dependencies should be
avoided if possible. Obviously, if the module is designed to be a wrapper around some other
library, avoiding the dependency is impossible. However, if reasonable, it is better to create
macros that can be redefined by the user or functions that the user can implement.
